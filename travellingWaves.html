<html >
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>2D neural propagation - Michael S. Clayton</title>
        <link rel="shortcut icon" href="brain.ico" type="image/x-icon">
        <link rel="icon" href="brain.ico" type="image/x-icon">
        <link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,900" rel="stylesheet">
        <link rel="stylesheet" href="libs/font-awesome/css/font-awesome.min.css">
        <link href="css/bootstrap.min.css" rel="stylesheet">
        <link href="https://cdn.rawgit.com/jpswalsh/academicons/master/css/academicons.min.css" rel="stylesheet" />
        <link href="css/styles.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.8/styles/default.min.css">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.8/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
    </head>

    <body style='background-color: #3f7693'>
        <div style="display: flex; font-size: 1.2em; padding-top: 2vh; padding-bottom: 2vh; align-content: center; justify-content: center">
            <a style='color: white;' href='https://michaelsmclayton.github.io/'><u>Back to the home page</u></a>
        </div>
        <div class="container" style="background-color: white; max-width: 75vw; align-content: center; justify-items: center;">
            <h1 style='color: black; font-size: 1.25em; text-align: center;'>Propagation of neural activity in 2-dimensional networks</h1>
            <p style="font-size: 1.0em;">
                This simulation models different ways of generating travelling (or propagating) waves in neural networks. Here, 400 neurons are arranged in a two-dimensional grid. Connection strengths between neurons are dependent on their Euclidean distance from each other. These distance values are entered into a Gaussian function, such that neurons with the smallest distances have a greatest connection strengths, while strengths get increasingly weaker as inter-neuron distance increases. The simulation shows that different patterns of propagating activity generated using leaky integrate-and-fire neurons and coupled Kuramoto oscillators.
            </p>
        </div>

        <div class="container" style="display: flex; max-width: 75vw; background-color: white; align-content: center; justify-items: center;">
            <div class="row">
                <div class="col-sm-12 col-md-6" style="margin-top: 2.5vh;">
                    <div style="display: flex; align-content: center; justify-content: center; background-color: black">
                        <p style="font-size: 1.0em; color: white; font-weight: 600; margin: 10px;" align=center>Leaky integrate-and-fire network</p>
                    </div>
                    <div style="display: flex; align-content: center; padding-bottom: 30px; justify-content: center; margin-top: 20px">
                        <img width="75%" height="80px" style="min-height: 2vw; max-height: 15vw; max-width: 100vw;" src="images/LIF_equation.png">
                    </div>
                    <iframe width="100%" height="350" src="https://www.youtube.com/embed/7nDXc5q6tTw?&autoplay=1&loop=1&playlist=7nDXc5q6tTw" frameborder="0" allow="autoplay" allowfullscreen></iframe>
                    <!-- <video align=center style="outline: none" width="100%" height="auto" controls>
                        <source src="videos/LIF_Propagation.mov" type="video/mp4">
                    Your browser does not support the video tag.
                    </video> -->
                    <div style="display: flex; align-content: center; justify-content: center; margin-top: 10px">
                        <div style="text-align: justify">
                            <p style="font-size: 0.75em;">
                                tau_m = membrane time constant<br>
                                u = membrane voltage<br>
                                u_rest = resting membrane voltage<br>
                                R = membrane resistance<br>
                                I(t) = input current at time t<br>
                            </p>
                            <p style="font-size: 1.0em;">
                                In this example, the 2D network is composed of leaky integrate-and-fire neurons. Consistent input activity in the central neuron is recieved, increasing it's membrane voltage until it spikes. When the central neuron spikes, due to its connectivity with it's neighbours, the spike propagates throughout the network. Due to conduction delays with increased distance, this wave slowly propagataes like a ripple on the surface of a pond.
                            </p>
                        </div>
                    </div>
                </div>
                <div class="col-sm-12 col-md-6" style="margin-top: 2.5vh;"">
                    <div style="display: flex; align-content: center; justify-content: center; background-color: black">
                        <p style="font-size: 1.0em; color: white; font-weight: 600; margin: 10px;" align=center>Kuramoto oscillator network</p>
                    </div>
                    <div style="display: flex; align-content: center; padding-bottom: 32px; justify-content: center; margin-top: 20px">
                        <img width="70%" height="80px" style="min-height: 2vh; max-height: 10vw; max-width: 100vw;" src="images/kuramoto_equation.jpeg">
                    </div>
                    <iframe width="100%" height="350" src="https://www.youtube.com/embed/x91XD23DN6g?&autoplay=1&loop=1&playlist=x91XD23DN6g" frameborder="0" allow="autoplay" allowfullscreen></iframe>
                    <!-- <video align=center style="outline: none" width="100%" height="auto"controls>
                        <source src="videos/KuramotoSynchronisation.mov" type="video/mp4">
                    Your browser does not support the video tag.
                    </video>  -->
                    <div style="display: flex; align-content: center; justify-content: center; margin-top: 10px">
                        <div style="text-align: justify">
                            <p style="font-size: 0.75em;">
                                theta = Kuramoto oscillator angle<br>
                                w_i = intrinsic (natural) frequency<br>
                                K = coupling constant<br>
                                N = population size<br>
                                i, j = pre-, post-synaptic neuron<br>
                            </p>
                            <p style="font-size: 1.0em;">
                                    Here, the 2D network is composed of coupled Kuramoto oscillators. The coupling strength (K) is starts at zero, but is then suddendly increased. The causes the rapid generation of large travelling waves. The coupling is constant is then brought back to zero. The travelling waves observed in this simulation are notable for the fact that their direction of movement changes markedly from moment to moment (in contrast to the leaky integrate-and-fire network)
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="container" style="margin-top: 0px; max-width: 75vw; background-color: white"> 
            <div class="row">
                <div class="col-sm-12">
                    <div style="display: flex; padding-top: 50px; align-content: center; justify-content: center;">
                        <div style="width: 30vw; min-width: 350px; background-color: black">
                            <p align=center style="font-size: 1.0em; color: white; margin: 10px; font-weight: 600">Python code</p>
                        </div>
                        
                    </div>
                <pre style="font-size: .75em">
                    <code class="python hljs">
from brian2 import *
from matplotlib.pyplot import *
# matplotlib.use("Agg")
import matplotlib.animation as animation
import numpy as np

# Define simulation parameters
neuronType = 'LIF' # 'Kuramoto', 'LIF'
BrianLogger.suppress_hierarchy('brian2.codegen') # suppress Brian warnings
useVariableDelays = True
groupLength = 20
N = groupLength**2
def getCentralLocation(groupLength):
    firstRowLength = (groupLength-1)
    columnsToCenter = groupLength * (int(groupLength/2)-1)
    rowsToCenter = int(groupLength/2)+1
    return firstRowLength + columnsToCenter + rowsToCenter
sourceNeuron = getCentralLocation(groupLength)

# -------------------------------------------
# Helper functions
# -------------------------------------------

# Define Gaussian function
def gaussian(distance, sig):
    return np.exp(-np.power(distance, 2.) / (2 * np.power(sig, 2.)))

# Get Euclidean distance
def euclideanDistance(postSynapticLocation, preSynapticLocation):
    return np.linalg.norm(postSynapticLocation - preSynapticLocation)

# Define function to get weight between two neurons
locations = [[x,y] for x in range(groupLength) for y in range(groupLength)]
@implementation('numpy', discard_units=True)
@check_units(i=1, j=1, sig=1, result=1)
def getDistance(i, j, sig=3):
    preSynapticLocation = np.array(locations[int(i)])
    postSynapticLocation = np.array(locations[int(j)])
    distance = euclideanDistance(postSynapticLocation, preSynapticLocation)
    return gaussian(distance, sig)

# Post-processing 1D to 2D data
def getRowIndices(groupLength):
    rowStarts = [(i*groupLength) for i in range(groupLength)]
    rowEnds = [((i+1)*groupLength) for i in range(groupLength)]
    return rowStarts, rowEnds
def convertToMatrix(data, groupLength):
    # Get row starts and ends
    rowStarts, rowEnds = getRowIndices(groupLength)
    # Initialise and then fill matrix
    if len(data.shape)==1:
        matrix = np.zeros(shape=[groupLength, groupLength])
        for row in range(groupLength):
            matrix[row,:] = data[range(rowStarts[row], rowEnds[row])]
    elif len(data.shape)==2:
        matrix = np.zeros(shape=[groupLength, groupLength, data.shape[-1]])
        for row in range(groupLength):
            matrix[row,:,:] = data[range(rowStarts[row], rowEnds[row]),]
    return matrix


# -------------------------------------------
# Create network
# -------------------------------------------
print('Creating network...')

# Define LIF neurons and synapses
if neuronType == 'LIF': 
    tau = 10*ms
    eqs = '''
        du/dt = (-u + ISyn)/tau + (.1*xi*tau**-0.5) : 1
        dISyn/dt = -ISyn * ms**-1 : 1
    '''
    G = NeuronGroup(N, eqs, threshold='u>1', reset='u=0', method='euler')
    G.u = '.5*rand()'
    trace = StateMonitor(G, ['u', 'ISyn'], record=True)
    S = Synapses(G, G, on_pre='''ISyn += 4''', method='euler')
    # Connect random input
    randomInput = PoissonGroup(50, np.arange(50)*Hz + 25*Hz)
    Sinput = Synapses(randomInput, G[sourceNeuron], on_pre = '''ISyn += .6''', method='euler')
    Sinput.connect()

# Define Kuramoto neurons and synapses
if neuronType == 'Kuramoto':
    eqs = '''
        dTheta/dt = ((freq + (kN * PIF)) * ms**-1) : 1
        PIF = .5 * (sin(ThetaPreInput - Theta)) : 1
        ThetaPreInput : 1
        freq : 1
        kN : 1
    '''
    G = NeuronGroup(N, eqs, threshold='True', method='euler')
    G.Theta = '2*(i/N)'
    G.freq = '1-(randn()*2)'
    trace = StateMonitor(G, ['Theta'], record=True)
    S = Synapses(G, G, on_pre = '''ThetaPreInput_post = Theta_pre''', method='euler')

# Connect synapses with distance-dependent connectivity
S.connect(condition='i!=j', p='getDistance(i,j)')

# Define synapse delays
if useVariableDelays==True:
    delayGaussianSigma = 3
    for syn in range(len(S)):
        currentI, currentJ = S.i[syn], S.j[syn]
        S.delay[syn] = 1/getDistance(currentI, currentJ, delayGaussianSigma) * ms
        # 1/getDistance(currentI, currentJ, delayGaussianSigma) * ms
        # euclideanDistance(currentI, currentJ) / 3.5*ms

# Run simulation
print('Running simulation...')
duration = 10*ms
if neuronType == 'Kuramoto':
    G.kN = 7
    run(duration, report='text')
    G.kN = 0
    run(duration*6, report='text')
    G.kN = 7
    run(duration, report='text')
    G.kN = 0
    run(duration*6, report='text')
if neuronType == 'LIF':
    run(duration*10, report='text')


# -------------------------------------------
# Plot results
# -------------------------------------------

# Animation
fig = figure(2, figsize=(6,6))
fig.set_facecolor((.8,.8,.8))
gca().set_facecolor((.8,.8,.8))

# Set up formatting for the movie files
Writer = animation.writers['ffmpeg']
writer = Writer(fps=15, metadata=dict(artist='Me'), bitrate=1800)

# Get trace of interest
if neuronType == 'LIF': 
    traceOfInterest = trace.u
elif neuronType == 'Kuramoto': 
    traceOfInterest = (cos(trace.Theta)+1)/2
axis('off')

# Initialise figure
def updatefig(t):
    global thetaMatrix
    im.set_array(np.transpose(thetaMatrix[:,:,t]))
    if t > 10:
        fig.set_facecolor((0,0,0))
    return im,
thetaMatrix = convertToMatrix(traceOfInterest, groupLength)
im = imshow(thetaMatrix[:,:,0], animated=True)
im.set_cmap('bone')
ani = animation.FuncAnimation(fig, updatefig, frames=traceOfInterest.shape[1], interval=1, blit=True)
# ani.save('travellingWaves_%s.mp4' % (neuronType), writer=writer)
show()  
                    </code>
                </pre>
            </div>
        </div>
    </body>

</html >
